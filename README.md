# YSAppSizeTest
Solution of reduce iOS application size(减少iOS应用程序尺寸的解决方案)。

---

通过对静态库的正确使用，可以有效的减少应用程序包的尺寸，其原理是根据对静态库的编译和链接规则得出来的，详细的原理介绍请参考文章：[深入iOS系统底层之静态库介绍](https://www.jianshu.com/p/ef3415255808)。

在本例中的同一个Workspace中分别建立ThinApp和FatApp两个工程，这两个工程实现的功能是一样。在整个应用程序中分别定义了CA、CB、CC、CD、CE一共5个OC类，定义了一个UIView(Test)分类，还有定义了两个C函数：libFoo1和libFoo1。

整个应用程序中只使用了CA和CC两个OC类，以及调用了UIView(Test)分类方法，以及调用了libFoo1函数，并且同时都采用导入静态库的形式。但是因为这两个工程对类文件的分布和引用策略不同使得两个应用程序的最终可执行代码的尺寸是不相同的。

### FatApp中的文件定义和分布策略
1. CA,CB两个类都定义在主程序工程中。
2. CC,CD,CE三个类，以及UIView(Test)分类，还有libFoo1,libFoo2两个函数都定义在FatAppLib静态库工程中。
3. CC,CD两个类定义在同一个文件中，CE类则定义在单独的文件中。
3. FatApp工程依赖并导入了FatAppLib静态库工程。
4. FatApp工程的Other Linker Flags中设置了 -ObjC选项。

### ThinApp中的文件定义和分布策略
1. UIView(Test)分类在ThinApp工程中被定义。
2. CA,CB,CC,CD,CE5个类，还有libFoo1,libFoo2两个函数都定义在ThinAppLib静态库工程中。
3. 上述的5个类都分别定义在不同的文件中。
4. ThinApp工程依赖并导入了ThinAppLib静态库工程。
5. ThinApp工程的Other Linker Flags中没有设置-ObjC选项。


因为上述的两个相同功能的工程的策略不同，在程序被Archive出来后，FatApp可执行程序的尺寸是367KB，而ThinApp可执行程序的尺寸是334KB。通过一些工具比如Mach-O View或者 IDA可以看出：FatApp中5个OC类的代码以及libFoo1函数，还有UIView(Test)分类的代码都被链接进可执行程序中；而ThinApp中则只有CA,CC两个类以及libFoo1函数，还有UIView(Test)分类的代码被链接进可执行程序中。

因此如果你要对你的应用进行瘦身处理时可以按照如下的规则来构建您的应用程序：

1. 尽量将代码都移植到静态库中，而主程序则保留为一个壳程序。我们可以通过在Xcode中工程依赖来构建和引入静态库工程，或者借助一些工程化工具Cocoapods来实现这种拆分处理。
2. 静态库中的每一个文件中最好只有一个类的实现，相同功能的代码以及可能都会被调用的代码尽量存放在一个文件中。
3. 尽量不要在主程序工程中使用-ObjC和-all_load两个选项而改为用-force_load 来单独指定要执行加载的静态库。另外一个就是尽量减少在静态库中定义OC类的分类方法，如果非要用分类方法那么可以将所有的分类方法定义在一个单独的静态库中，并通过-force_load来加载这个静态库。
4.  除了可以通过-force_load来加载指定静态库中的所有代码外。我们还可以在构建静态库时，在静态库的工程的`Build Settings`中将**Perform Single-Object Prelink** 中的开关选项打开。当这个开关打开时，系统会对生成的静态库的所有目标文件执行预链接操作，预链接操作会将所有的目标文件组合成为一个单独的大的目标文件。这样根据上述的以文件为单位的链接规则就会将静态库中的所有代码全部都链接进可执行程序中去，但是这样带来的问题就是最后在dead code stripping时删除不掉已经链接进来的那些没有被任何地方使用过的OC类了。
5. 对于引入的一些第三方静态库来说，如果这个静态库中没有任何分类代码的定义则正常引用即可，如果静态库中有分类方法的定义则单独对这个静态库采用-force_load选项。还有一个方法如果这个第三方静态库中的分类方法是定义在一个单独文件中的话可以借助ar命令来将这些目标文件从静态库中进行分离然后进行单独的目标文件链接处理。

**总之一句话：为了让你的程序瘦身，不要在静态库中定义分类！！**

